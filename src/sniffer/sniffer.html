<!DOCTYPE html>
<html lang="en">

<head>
  <link rel="stylesheet" href="../css/footer.css">
  <link rel="stylesheet" href="../css/sniffer.css">
  <link rel="stylesheet" href="../css/dark-theme.css" id="theme">
  <title>Rock Buddy (alpha test)</title>
</head>

<body>
  <div class="navtop">
    <a href="../sniffer/sniffer.html">Sniffer</a> |
    <a href="../search/search.html">Search</a> |
    <a href="../account/account.html">Account</a>
    <a href="../config/config.html" style="float: right;">Config</a>
  </div>
  <div style="display: flex; flex-direction: row; align-items: center; width: 100%;">
    <h1>Leaderboard Sniffer</h1>
    <div class="ready" style="margin-left: auto; display: none;">
      <div class="status" style="display: inline-block;">
        Sniffing...
      </div>
      <div style="display: inline-block;">
        <button id="snort" title="Force an immediate refresh of the data." onclick="snortData()">Snort </button>
      </div>
    </div>
  </div>
  <div class="loading">
    <p>Loading...</p>
  </div>
  <div id="error" class="error" style="display: none;">
  </div>
  <div class="waiting" style="display: none;">
    <p>Waiting for Rocksniffer...</p>
  </div>
  <div class="connected" style="display: none;">
    <p>Navigate to a song in Rocksmith to begin sniffing...</p>
  </div>
  <div class="ready" style="display: none;">
    <div id="leaderboard_header" style="display: none;">
      <div style="display: flex; flex-direction: row; width: 100%;">
        <div style="display: flex; flex-direction: row; gap: 10px; width: 50%">
          <div>
            <img class="coveralbum" id="album_art">
          </div>
          <div
            style="display: flex; flex-direction: column; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
            <h4 id="artist" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin: 2px;"></h4>
            <h4 id="title" style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin: 2px;"></h4>
            <h4 style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin: 2px;">
              <span id="album"></span> (<span id="year"></span>)
            </h4>
            <div
              style="font-size: small; margin-left: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
              <em>Version <span id="version"></span> - <span id="author"></span></em>
            </div>
          </div>
        </div>
        <div class="live-data" style="display: flex; flex-direction: row; width: 50%">
          <div style="display:flex; flex-direction: row; width: 50%; align-items: center; align-self: flex-start;">
            <div class="circle" id="live_feed_icon" style="margin-right: 10px;"></div>
            <div>Live Feed</div>
          </div>
          <div id="stats_las" style="display:flex; flex-direction: column; margin-left: auto; display: none;">
            <div style="display:flex; flex-direction: row; margin-left: auto;">
              <span style="margin-right: 10px;">Accuracy:</span><span id="notes_hit">0</span>/<span id="total_notes">0</span>&nbsp;(<span id="accuracy" >NaN</span>)
            </div>
            <div style="display:flex; flex-direction: row; margin-left: auto;">
              <span style="margin-left: auto; margin-right: 10px;">Streak:</span><span id="streak">0</span>/<span id="highest_streak"></span>
            </div>
          </div>
        </div>
      </div>
      <br>
      <div style="display: flex; flex-direction: row; gap: 5px;">
        <label for="game_mode">Game Mode:</label>
        <select id="game_mode" style="margin-right: 10px;">
          <option value="las" selected>Learn A Song</option>
          <option value="sa">Score Attack</option>
        </select>

        <label for="path">Path:</label>
        <select id="path" style="margin-right: 10px;">
        </select>

        <div id="score_attack" style="display: none;">
          <label for="difficulty">Difficulty:</label>
          <select id="difficulty" style="margin-right: 10px;">
            <option value="hard" selected>Hard</option>
            <option value="master">Master</option>
          </select>
        </div>
      </div>
    </div>
    <br>
    <div id="leaderboard_data" style="display: none;">
      <p>And this is where I would put my score... <em>IF I HAD ONE!</em></p>
    </div>
  </div>
  <div id="modal" class="modal">
    <span class="close">&times;</span>
    <center>
      <h3>You found Boulder Bro, Rock Buddy's big brother!</h3>
    </center>
    <img src="./../../images/boulder-bro.png" alt="you found him!">
  </div>
  <script>
    const pressed = [];
    const secretCode = 'ArrowUpArrowUpArrowDownArrowDownArrowLeftArrowRightArrowLeftArrowRightba';
    const modal = document.getElementById('modal');
    const closeBtn = document.querySelector('.close');

    window.addEventListener('keyup', (e) => {
      pressed.push(e.key);
      pressed.splice(-secretCode.length - 1, pressed.length - secretCode.length);
      if (pressed.join('').includes(secretCode)) {
        modal.style.display = 'block';
      }
    });

    closeBtn.addEventListener('click', () => {
      modal.style.display = 'none';
    });
  </script>
  <footer>
    <p>
    <div class="copyright">
      Copyright &copy; 2023 <a class="tntrocks" href="mailto:tntmusicstudios2018@gmail.com">TNTMusicStudios</a>
    </div>
    <div class="team-mem">
      <a href="./../team.html">Team</a>
    </div>
    </p>
  </footer>
  <script src="../common/functions.js"></script>
  <script src="../../node_modules/jquery/dist/jquery.min.js"></script>
  <script>
    'use strict';
    sessionUpdate();

    const userId = JSON.parse(sessionStorage.getItem('auth_data'))['user_id'];

    // If the page is starting up we want to immediately pull data
    let startup = true;

    // Variables to control polling of Rocksniffer and the Rock Buddy server
    const pollRate = 1000; // Rocksniffer poll rate
    let pollTime = 0; // Add delay to sync data to not overwhelm the server
    let requestActive = false;
    let currentSong = null;
    let sync = true;
    let countDown = 10;

    // Allow the user to snort data immediately if they wish
    const snortRate = 10000; // Rock Buddy server poll rate
    let snort = false;
    let lastSnort = snortRate; // Allow the user to snort immediately
    let snorted = false; // Keep track if a snort has occurred for the current song

    // TODO: store these so they persist between sessions
    let selectedGameMode = 'las';
    let selectedPath = null;
    let selectedDifficulty = 'hard';

    // Store data globally so we can react to combo box changes quickly
    let rocksnifferData = null;
    let previousRocksnifferData = null;
    let songData = null;
    let previousSongData = null;

    async function refresh() {
      pollTime += pollRate;
      lastSnort += pollRate;

      if (requestActive) {
        console.warn('A request is already active, returning.');
        return;
      }

      requestActive = true;

      rocksnifferData = await getRocksnifferData();
      if (rocksnifferData === null) {
        requestActive = false;
      }
      else if (rocksnifferData['success']) {
        showClass('ready');

        if (snort === false && lastSnort >= snortRate) {
          document.getElementById('snort').disabled = false;
        }

        // If user data file is updated, trigger a snort
        const steamUserDataPath = sessionStorage.getItem('steam_user_data_path');
        const steamProfile = sessionStorage.getItem('steam_profile');
        const rocksmithProfile = sessionStorage.getItem('rocksmith_profile');
        const newData = await api.checkForNewRocksmithProfileData(steamUserDataPath, steamProfile, rocksmithProfile);

        // If we are switching songs, don't keep syncing
        let previousSong = false;
        if (rocksnifferData['songDetails']['songID'] !== currentSong) {
          countDown = 10; // Reset countdown on song change

          // When the song changes we are not in a song
          document.getElementById('live_feed_icon').style.backgroundColor = 'red';
          document.getElementById('stats_las').style.display = 'none';

          sync = true;
          pollTime = 0;
          lastSnort = snortRate; // Allow user to snort immediately
          snorted = false;

          // If new data is detected right as a song is switching, snort the previous song data
          if (newData && previousSongData !== null) {
            await syncData(true);
            requestActive = false;
            return;
          }
          else {
            currentSong = rocksnifferData['songDetails']['songID'];
          }
        }

        // If we have not switched songs for 10 seconds perform a sync and display the data
        if (startup === true || newData === true || snort === true || (pollTime >= snortRate && sync === true)) {
          startup = false; // We have started now so set to false
          sync = false; // Don't keep syncing indefinitely
          snort = false; // Don't keep snorting indefinitely
          document.getElementById('snort').disabled = true;
          lastSnort = 0;

          const leaderboardData = document.getElementById('leaderboard_data');
          leaderboardData.innerHTML = '';
          const snortText = document.createElement('em');
          snortText.textContent = '*Snort*';
          leaderboardData.appendChild(snortText);
          leaderboardData.style.display = 'block';

          selectedPath = await getPreferredPath();

          $('div.status').html('Snorting data...');

          await syncData();
          snorted = true;
          countDown = 10; // Reset countdown
          await displayRocsnifferData();

          await displayLeaderboardData();
        }
        else if (pollTime < snortRate && sync === true) {
          const leaderboardData = document.getElementById('leaderboard_data');
          leaderboardData.innerHTML = '';
          leaderboardData.appendChild(document.createTextNode('Snorting data in ' + countDown--));
          leaderboardData.style.display = 'block';
        }

        previousRocksnifferData = rocksnifferData;

        $('div.status').html('Sniffing...');

        displayRocsnifferData();

        // If a song is active in learn a song, display stats_las
        if (selectedGameMode === 'las' && (rocksnifferData['memoryReadout']['gameStage'] === 'las_game' || rocksnifferData['memoryReadout']['gameStage'] === 'nonstopplaygame')) {
          document.getElementById('stats_las').style.display = 'block';
          document.getElementById('live_feed_icon').style.backgroundColor = 'green';

          const notesHit = rocksnifferData['memoryReadout']['noteData']['TotalNotesHit'];
          document.getElementById('notes_hit').innerText = notesHit;

          const totalNotes = rocksnifferData['memoryReadout']['noteData']['TotalNotes'];
          document.getElementById('total_notes').innerText = totalNotes;

          const accuracy = rocksnifferData['memoryReadout']['noteData']['Accuracy'];
          document.getElementById('accuracy').innerText = accuracy.toFixed(2) + '%';

          const streak = rocksnifferData['memoryReadout']['noteData']['CurrentHitStreak'];
          document.getElementById('streak').innerText = streak;

          const highestStreak = rocksnifferData['memoryReadout']['noteData']['HighestHitStreak'];
          document.getElementById('highest_streak').innerText = highestStreak;

          // Follow the correct arrangment with Rocksniffer
          const arrangementHash = rocksnifferData['memoryReadout']['arrangementID'];
          if (songData !== null && snorted === true) {

            // It takes a second for the arrangement ID to update so check that it exists for the current song
            if (songData['arrangements'].hasOwnProperty(arrangementHash)) {
              const arrangementName = songData['arrangements'][arrangementHash]['name'];

              const pathComboBox = document.querySelector('#path');
              pathComboBox.value = arrangementName.toLowerCase();

              let event = new Event('change');
              pathComboBox.dispatchEvent(event);
            }
          }
        }
        else {
          document.getElementById('live_feed_icon').style.backgroundColor = 'red';
        }
      }
      else {
        showClass('connected');
      }

      requestActive = false;
    }

    async function snortData() {
      snort = true;
      document.getElementById('snort').disabled = true;
    }

    function getAvailablePaths() {
      let paths = [];

      // Get bonus and alt count by looping through once
      let bonusCount = {};
      let altCount = {};
      rocksnifferData['songDetails']['arrangements'].forEach((arrangement) => {
        const type = arrangement['type'];

        // If it is a bonus arrangement build the appropriate name
        if (arrangement['isBonusArrangement']) {
          if (!bonusCount.hasOwnProperty(type)) {
            bonusCount[type] = 0;
          }
          bonusCount[type]++;
        }

        // If it is an alt arrangement build the appropriate name
        else if (arrangement['isAlternateArrangement']) {
          if (!altCount.hasOwnProperty(type)) {
            altCount[type] = 0;
          }
          altCount[type]++;
        }
      });

      // Keep track of bonus and alt indexes to handle bonus and alt arrangement types
      let bonusIndex = 1;
      let altIndex = 1;
      let index = 0;
      rocksnifferData['songDetails']['arrangements'].forEach((arrangement) => {
        let path = '';
        let sortString = '';

        // Special logic to handle bonus and alt arrangement types
        const type = arrangement['type'];

        if (type === 'Lead') {
          sortString += 'a';
        }
        else if (type === 'Rhythm') {
          sortString += 'b';
        }
        else if (type === 'Bass') {
          sortString += 'c';
        }

        // If it is a bonus arrangement build the appropriate name
        if (arrangement['isBonusArrangement']) {
          path = 'Bonus ' + type;
          sortString += 'b';

          if (bonusCount[type] > 1) {
            path += ' ' + bonusIndex;
            sortString += bonusIndex;
          }

          bonusIndex++;
        }

        // If it is an alt arrangement build the appropriate name
        else if (arrangement['isAlternateArrangement']) {
          path = 'Alternate ' + type;
          sortString += 'a';

          if (altCount[type] > 1) {
            path += ' ' + altIndex;
            sortString += altIndex;
          }

          altIndex++
        }
        else {
          path = arrangement['type'];
        }

        paths[index++] = {
          name: path,
          sort: sortString
        };
      });

      return paths;
    }

    async function syncWithServer(songData) {
      const authData = JSON.parse(sessionStorage.getItem('auth_data'));

      const host = await api.getHost();
      const response = await post(host + '/api/data/sniffer_sync.php', {
        auth_data: authData,
        song_data: songData
      });

      if ('error' in response) {
        api.error(response['error']);
        return null;
      }

      return response;
    }

    async function syncData(previousSong = false) {
      let snifferData = null;
      if (previousSong) {
        snifferData = previousRocksnifferData;
      }
      else {
        snifferData = rocksnifferData;
      }

      const rocksmithData = await getRocksmithProfileData();

      songData = {};

      // Get basic song metadata
      songData['song_key'] = snifferData['songDetails']['songID'];
      songData['psarc_hash'] = snifferData['songDetails']['psarcFileHash'];
      songData['title'] = snifferData['songDetails']['songName'];
      songData['artist'] = snifferData['songDetails']['artistName'];
      songData['album'] = snifferData['songDetails']['albumName'];
      songData['year'] = snifferData['songDetails']['albumYear'];

      // Loop through each arrangement
      songData['arrangements'] = {};

      // Get available paths for song
      let availablePaths = getAvailablePaths();

      let index = 0;
      snifferData['songDetails']['arrangements'].forEach((arrangement) => {
        const hash = arrangement['arrangementID'];

        let arrangementData = {};

        arrangementData['name'] = availablePaths[index++]['name'];
        arrangementData['hash'] = hash;

        const lasDataExists = rocksmithData['Stats']['Songs'].hasOwnProperty(hash);
        const saDataExists = rocksmithData['SongsSA'].hasOwnProperty(hash);
        if (lasDataExists) {
          arrangementData['mastery'] = rocksmithData['Stats']['Songs'][hash]['MasteryPeak'];
          arrangementData['last_accuracy'] = rocksmithData['Stats']['Songs'][hash]['AccuracyGlobal'];
          arrangementData['streak'] = rocksmithData['Stats']['Songs'][hash]['Streak'];
          arrangementData['las_last_played'] = rocksmithData['Stats']['Songs'][hash]['DateLAS'];
          arrangementData['las_play_count'] = rocksmithData['Stats']['Songs'][hash]['PlayedCount'];
        }
        if (saDataExists) {
          arrangementData['scores'] = {};
          arrangementData['badges'] = {};

          // Scores
          // Keep easy and medium commented out in case we want to add them later
          //arrangementData['scores']['easy'] = rocksmithData['SongsSA'][hash]['HighScores']['Easy'];
          //arrangementData['scores']['medium'] = rocksmithData['SongsSA'][hash]['HighScores']['Medium'];
          arrangementData['scores']['hard'] = rocksmithData['SongsSA'][hash]['HighScores']['Hard'];
          arrangementData['scores']['master'] = rocksmithData['SongsSA'][hash]['HighScores']['Master'];

          // Strikes
          // Keep easy and medium commented out in case we want to add them later
          //arrangementData['badges']['easy'] = rocksmithData['SongsSA'][hash]['Badges']['Easy'];
          //arrangementData['badges']['medium'] = rocksmithData['SongsSA'][hash]['Badges']['Medium'];
          arrangementData['badges']['hard'] = rocksmithData['SongsSA'][hash]['Badges']['Hard'];
          arrangementData['badges']['master'] = rocksmithData['SongsSA'][hash]['Badges']['Master'];

          arrangementData['sa_last_played'] = rocksmithData['Stats']['Songs'][hash]['DateSA'];
          arrangementData['sa_play_count'] = rocksmithData['SongsSA'][hash]['PlayCount'];
        }

        songData['arrangements'][hash] = arrangementData;
      });

      // Sort the available paths
      availablePaths.sort((a, b) => a['sort'].localeCompare(b['sort']));
      const availablePathNames = availablePaths.map(obj => obj['name'].toLowerCase());

      // If the selected path doesn't exist for this song, update it to one that does
      if (!availablePathNames.includes(selectedPath)) {
        selectedPath = availablePathNames[0];
      }

      // Build the paths combo box with the available options
      const pathComboBox = document.querySelector('#path');
      pathComboBox.innerHTML = '';
      availablePaths.forEach((path) => {
        const option = document.createElement('option');
        option.text = path['name'];
        option.value = path['name'].toLowerCase();

        if (option.value === selectedPath) {
          option.selected = true;
        }

        pathComboBox.appendChild(option);
      });

      await syncWithServer(songData);

      if (!previousSong) {
        previousSongData = songData;
      }
    }

    async function getScoresLAS(snifferData) {
      const authData = JSON.parse(sessionStorage.getItem('auth_data'));

      const host = await api.getHost();
      const response = await post(host + '/api/data/get_scores_las.php', {
        auth_data: authData,
        song_key: snifferData['songDetails']['songID'],
        psarc_hash: snifferData['songDetails']['psarcFileHash'],
        arrangement: selectedPath
      });

      if ('error' in response) {
        api.error(response['error']);
        return null;
      }

      return response;
    }

    async function displayRocsnifferData() {
      document.getElementById('album_art').src = 'data:image/jpeg;base64,' + rocksnifferData['songDetails']['albumArt'];
      document.getElementById('artist').innerText = rocksnifferData['songDetails']['artistName'];
      document.getElementById('title').innerText = rocksnifferData['songDetails']['songName'];
      document.getElementById('album').innerText = rocksnifferData['songDetails']['albumName'];
      document.getElementById('year').innerText = rocksnifferData['songDetails']['albumYear'];
      document.getElementById('version').innerText = rocksnifferData['songDetails']['toolkit']['version'];
      document.getElementById('author').innerText = rocksnifferData['songDetails']['toolkit']['author'];
      document.getElementById('leaderboard_header').style.display = 'block';
    }

    async function displayLeaderboardData() {

      // If snorting has not happened for the current song yet force a snort
      // after the snort displayData will be called again by the refresh
      if (!snorted) {
        snortData();
        return;
      }

      const leaderboardData = document.getElementById('leaderboard_data');
      if (selectedGameMode === 'las') {
        const scoresLAS = await getScoresLAS(rocksnifferData);
        if (scoresLAS === null) {
          // An error has occurred
          return;
        }

        if (scoresLAS.length === 0) {
          leaderboardData.innerHTML = '';
          leaderboardData.appendChild(document.createTextNode('No scores found.'));
          leaderboardData.style.display = 'block';
          return;
        }

        // Create table element
        const table = document.createElement('table');
        table.border = 1;
        table.style.width = '100%';

        // Create header row
        const headerRow = document.createElement('tr');

        const headers = ['Rank', 'Username', 'Last Played', 'Last Accuracy', 'Play Count', 'Streak', 'Mastery'];
        headers.forEach((header) => {
          const headerCell = document.createElement('th');
          headerCell.style.fontFamily = "Roboto Mono, monospace";
          headerCell.appendChild(document.createTextNode(header));
          headerRow.appendChild(headerCell);
        })

        table.appendChild(headerRow);

        // Create data rows
        const columns = ['rank', 'username', 'last_played', 'last_accuracy', 'play_count', 'streak', 'mastery'];
        const columnsAlign = ['right', 'left', 'left', 'right', 'right', 'right', 'right'];

        // Keep track of rank
        let rank = 1;
        scoresLAS.forEach((row) => {
          const dataRow = document.createElement('tr');

          // Populate data for each column
          let columnIndex = 0;
          columns.forEach((column) => {
            const dataCell = document.createElement('td');
            dataCell.style.fontFamily = "Roboto Mono, monospace";
            if (column === 'rank') {
              dataCell.appendChild(document.createTextNode(rank++));
            }
            else if (column === 'mastery' || column === 'last_accuracy') {
              const percentage = (row[column] * 100).toFixed(2) + '%';
              dataCell.appendChild(document.createTextNode(percentage));
            }
            else {
              dataCell.appendChild(document.createTextNode(row[column]));
            }
            dataCell.style.textAlign = columnsAlign[columnIndex++];
            dataRow.appendChild(dataCell);
          });

          // Add the row to the table
          table.appendChild(dataRow);
        })

        leaderboardData.innerHTML = '';
        leaderboardData.appendChild(table);
        leaderboardData.style.display = 'block';
      }
      else {
        const data = document.createElement('div');
        data.appendChild(document.createTextNode('Selected game mode not yet supported. Check back soon!'));

        leaderboardData.innerHTML = '';
        leaderboardData.appendChild(data);
        leaderboardData.style.display = 'block';
      }
    }

    async function checkForNewRocksmithProfileData() {
      const steamUserDataPath = sessionStorage.getItem('steam_user_data_path');
      const steamProfile = sessionStorage.getItem('steam_profile');
      const rocksmithProfile = sessionStorage.getItem('rocksmith_profile');

      return await api.checkForNewRocksmithProfileData(steamUserDataPath, steamProfile, rocksmithProfile);
    }

    async function getRocksmithProfileData() {
      const steamUserDataPath = sessionStorage.getItem('steam_user_data_path');
      const steamProfile = sessionStorage.getItem('steam_profile');
      const rocksmithProfile = sessionStorage.getItem('rocksmith_profile');

      return await api.getRocksmithProfileData(steamUserDataPath, steamProfile, rocksmithProfile);
    }

    async function getRocksnifferData() {
      const rocksnifferHost = sessionStorage.getItem('rocksniffer_host');
      const rocksnifferPort = sessionStorage.getItem('rocksniffer_port');

      //JSON query the addon service
      try {
        const response = await $.get("http://" + rocksnifferHost + ":" + rocksnifferPort);
        showClass('connected');

        let randomNumber = Math.floor(Math.random() * 69) + 1;
        if (randomNumber === 69) {
          console.log('*sniff sniff*');
        }

        return response;
      } catch (error) {
        showClass('waiting');
        return null;
      }
    }

    async function showClass(className) {
      const classNames = {
        loading: document.getElementsByClassName('loading'),
        error: document.getElementsByClassName('error'),
        waiting: document.getElementsByClassName('waiting'),
        connected: document.getElementsByClassName('connected'),
        ready: document.getElementsByClassName('ready')
      };

      const classNameKeys = Object.keys(classNames);
      classNameKeys.forEach((c) => {
        if (className === c) {
          for (let i = 0; i < classNames[c].length; i++) {
            classNames[c][i].style.display = 'block';
          }
        }
        else {
          for (let i = 0; i < classNames[c].length; i++) {
            classNames[c][i].style.display = 'none';
          }
        }
      });
    }

    async function connectToRocksmith() {
      let steamUserDataPath = sessionStorage.getItem('steam_user_data_path');
      let steamProfile = sessionStorage.getItem('steam_profile');
      let rocksmithProfile = sessionStorage.getItem('rocksmith_profile');

      if (steamUserDataPath === null || steamProfile === null || rocksmithProfile === null) {
        steamUserDataPath = await api.storeGet('user_data.' + userId + '.steam_user_data_path');
        steamProfile = await api.storeGet('user_data.' + userId + '.steam_profile');
        rocksmithProfile = await api.storeGet('user_data.' + userId + '.rocksmith_profile');

        if (steamUserDataPath === null || steamProfile === null || rocksmithProfile === null) {
          document.getElementById('error').innerHTML = '<p>Could not find Rocksmith user data. Check that your config settings are correct.</p>';
          showClass('error');
          return false;
        }

        sessionStorage.setItem('steam_user_data_path', steamUserDataPath);
        sessionStorage.setItem('steam_profile', steamProfile);
        sessionStorage.setItem('rocksmith_profile', rocksmithProfile);
      }

      return true;
    }

    async function connectToRocksniffer() {
      const rocksnifferHost = sessionStorage.getItem('rocksniffer_host');
      const rocksnifferPort = sessionStorage.getItem('rocksniffer_port');

      // If we don't have the host and port, get it
      if (rocksnifferHost === null || rocksnifferPort === null) {
        const rocksnifferPath = await api.storeGet('user_data.' + userId + '.rocksniffer_path');
        if (rocksnifferPath === null) {
          document.getElementById('error').innerHTML = '<p>Could not find Rocksniffer. Check that your config settings are correct.</p>';
          showClass('error');
          return false;
        }

        // Check that the provided Rocksniffer version is compatible
        const versionFile = await api.pathJoin(rocksnifferPath, 'version.txt');
        const version = await api.readFile(versionFile);
        const requiredVersion = 'v0.4.1';
        if (!await api.semverGte(version, requiredVersion)) {
          document.getElementById('error').innerHTML = '<p>Unsupported Rocksniffer version. Please update Rocksniffer to at least ' + requiredVersion + '.</p>';
          showClass('error');
          return false;
        }

        const addonConfigFile = await api.pathJoin(rocksnifferPath, 'config', 'addons.json');
        const addonConfig = JSON.parse(await api.readFile(addonConfigFile));

        // Make sure addons are enabled
        if (!addonConfig['enableAddons']) {
          console.log('Enabling Rocksniffer addons.');
          addonConfig['enableAddons'] = true;
          await api.writeFile(addonConfigFile, JSON.stringify(addonConfig, null, 2));
        }

        sessionStorage.setItem('rocksniffer_host', addonConfig['ipAddress']);
        sessionStorage.setItem('rocksniffer_port', addonConfig['port']);
      }

      return true;
    }

    async function getPreferredPath() {
      let preferredPath = sessionStorage.getItem('preferred_path');
      if (preferredPath === null) {
        preferredPath = await api.storeGet('user_data.' + userId + '.preferred_path');

        if (preferredPath === null) {
          preferredPath = 'lead';
        }

        sessionStorage.setItem('preferred_path', preferredPath);
      }

      return preferredPath;
    }

    async function main() {
      const rocksmithConnected = await connectToRocksmith();
      const rocksnifferConnected = await connectToRocksniffer();

      // Setup combo boxes
      const gameModeComboBox = document.querySelector('#game_mode');

      gameModeComboBox.addEventListener('change', async () => {
        const selectedOption = gameModeComboBox.options[gameModeComboBox.selectedIndex];
        selectedGameMode = selectedOption.value;

        if (selectedGameMode === 'las') {
          document.getElementById('score_attack').style.display = 'none';
        }
        else if (selectedGameMode == 'sa') {
          document.getElementById('stats_las').style.display = 'none';
          document.getElementById('score_attack').style.display = 'block';
        }

        // Update the display (keep things feeling responsive)
        await displayLeaderboardData();
      });

      const pathComboBox = document.querySelector('#path');
      pathComboBox.addEventListener('change', async () => {
        const selectedOption = pathComboBox.options[pathComboBox.selectedIndex];
        selectedPath = selectedOption.value;

        // Update the display (keep things feeling responsive)
        await displayLeaderboardData();
      });

      const difficultyComboBox = document.querySelector('#difficulty');
      difficultyComboBox.addEventListener('change', async () => {
        const selectedOption = difficultyComboBox.options[difficultyComboBox.selectedIndex];
        selectedDifficulty = selectedOption.value;

        // Update the display (keep things feeling responsive)
        await displayLeaderboardData();
      });

      if (rocksmithConnected && rocksnifferConnected) {
        setInterval(refresh, pollRate);
        refresh();
      }
    }

    main();
  </script>
  <script>
    document.documentElement.style.setProperty('--streamer-color', '#FFF');
    document.documentElement.style.setProperty('--streamer-text-color', '#e66b07');

    document.addEventListener("DOMContentLoaded", function () {
      const theme = localStorage.getItem("theme");
      if (theme) {
        const themeSelect = document.getElementById("theme-select");
        themeSelect.value = theme;

        const themeLink = document.getElementById("theme");
        themeLink.href = `../css/${theme}-theme.css`;
      }

      if (theme === "streamer") {
        const streamerColor = localStorage.getItem("streamer-color");
        if (streamerColor) {
          const streamerColorInput = document.getElementById("streamer-color");
          streamerColorInput.value = streamerColor;
          setStreamerColor();
        }

        const streamerTextColor = localStorage.getItem("streamer-text-color");
        if (streamerTextColor) {
          const streamerTextColorInput = document.getElementById("streamer-text-color");
          streamerTextColorInput.value = streamerTextColor;
          setStreamerTextColor();
        }
      }
    });

    function setTheme() {
      const themeSelect = document.getElementById("theme-select");
      const theme = themeSelect.value;
      const themeLink = document.getElementById("theme");

      if (theme === "streamer") {
        const streamerColorInput = document.getElementById("streamer-color");
        const streamerColor = streamerColorInput.value;
        document.body.style.background = streamerColor;
        localStorage.setItem("streamer-color", streamerColor);

        const streamerTextColorInput = document.getElementById("streamer-text-color");
        const streamerTextColor = streamerTextColorInput.value;
        document.body.style.color = streamerTextColor;
        localStorage.setItem("streamer-text-color", streamerTextColor);
      } else {
        document.body.style.background = null;
        localStorage.removeItem("streamer-color");
        document.body.style.color = null;
        localStorage.removeItem("streamer-text-color");
      }

      themeLink.href = `../css/${theme}-theme.css`;
      localStorage.setItem("theme", theme);
    }

    function setStreamerColor() {
      const theme = localStorage.getItem("theme");
      if (theme === "streamer") {
        const streamerColorInput = document.getElementById("streamer-color");
        const streamerColor = streamerColorInput.value;

        document.body.style.background = streamerColor;
        document.documentElement.style.setProperty('--streamer-color', streamerColor);

        localStorage.setItem("streamer-color", streamerColor);
      }
    }

    function setStreamerTextColor() {
      const theme = localStorage.getItem("theme");
      if (theme === "streamer") {
        const streamerTextColorInput = document.getElementById("streamer-text-color");
        const streamerTextColor = streamerTextColorInput.value;

        document.body.style.color = streamerTextColor;
        document.documentElement.style.setProperty('--streamer-text-color', streamerTextColor);

        localStorage.setItem("streamer-text-color", streamerTextColor);
      }
    }

  </script>


  <select style="display: none;" id="theme-select" onchange="setTheme()">
    <option value="light">Light theme</option>
    <option value="dark">Dark theme</option>
    <option value="streamer">Streamer theme</option>
  </select>

  <label style="display: none;" id="streamer-color-name" for="streamer-color">Background Color:</label>
  <input style="display: none;" type="color" id="streamer-color" name="streamer-color" onchange="setStreamerColor()">

  <label style="display: none;" id="streamer-text-color-name" for="streamer-text-color">Text Color:</label>
  <input style="display: none;" class="colortext" type="color" id="streamer-text-color" name="streamer-text-color"
    onchange="setStreamerTextColor()">
</body>

</html>