<!DOCTYPE html>
<html lang="en">
<head>
  <title>Rock Buddy</title>
</head>
<body>
  <div>
    <a href="../sniffer/sniffer.html">Sniffer</a> |
    <a href="../search/search.html">Search</a> |
    <a href="../account/account.html">Account</a>
    <a href="../config/config.html" style="float: right;">Config</a>
  </div>
  <h1>Leaderboard Sniffer</h1>
  <div id="loading">
    <p>Loading...</p>
  </div>
  <div id="error" style="display: none;">
  </div>
  <div id="waiting" style="display: none;">
    <p>Waiting for Rocksniffer...</p>
  </div>
  <div id="connected" style="display: none;">
    <div class="status">
      Sniffing...
    </div>
    <div class="data">

    </div>
  </div>
  <script src="../common/functions.js"></script>
  <script src="../../node_modules/jquery/dist/jquery.min.js"></script>
  <script>
    'use strict';
    sessionUpdate();

    const pollRate = 1000;
    let pollTime = 0; // Add delay to sync data to not overwhelm the server
    let requestActive = false;
    let currentSong = null;
    let sync = true;

    async function refresh() {
      pollTime += pollRate;

      if (requestActive) {
        console.warn('A request is already active, returning.');
        return;
      }

      requestActive = true;

      const rocksnifferData = await getRocksnifferData();
      if (rocksnifferData === null) {
        requestActive = false;
      }
      else if (rocksnifferData['success']) {
        displayData(rocksnifferData);

        // If we are switching songs, don't keep syncing
        if (rocksnifferData['songDetails']['songID'] !== currentSong) {
          currentSong = rocksnifferData['songDetails']['songID'];
          pollTime = 0;
          sync = true;
        }

        // If we have not switched songs for 5 seconds perform a sync
        else if (pollTime >= 5000 && sync === true) {
          sync = false; // Don't keep syncing indefinitely
          await syncData(rocksnifferData);
        }

        $('div.status').html('Sniffing...');
      }
      else {
        $('div.status').html('Navigate to a song in Rocksmith...');
      }

      requestActive = false;
    }

    async function displayData(rocksnifferData) {

    }

    async function writeSongData(songData) {
      const authData = JSON.parse(sessionStorage.getItem('auth_data'));

      console.log(songData);

      const host = await api.getHost();
      const response = await post(host + '/api/data/sniffer_sync.php', {
        auth_data: authData,
        song_data: songData
      });

      if ('error' in response) {
        api.error(response['error']);
        return false;
      }

      console.log(response);
      return true;
    }

    async function syncData(rocksnifferData) {
      $('div.status').html('Syncing data...');
      const rocksmithData = await getRocksmithProfileData();
      let songData = {};
      
      // Get basic song metadata
      songData['song_key'] = rocksnifferData['songDetails']['songID'];
      songData['psarc_hash'] = rocksnifferData['songDetails']['psarcFileHash'];
      songData['title'] = rocksnifferData['songDetails']['songName'];
      songData['artist'] = rocksnifferData['songDetails']['artistName'];
      songData['album'] = rocksnifferData['songDetails']['albumName'];
      songData['year'] = rocksnifferData['songDetails']['albumYear'];

      // Loop through each arrangement
      songData['arrangements'] = {};

      // Get bonus and alt count by looping through once
      let bonusCount = {};
      let altCount = {};
      rocksnifferData['songDetails']['arrangements'].forEach((arrangement) => {
        const type = arrangement['type'];

        // If it is a bonus arrangement build the appropriate name
        if (arrangement['isBonusArrangement']) {
          if (!bonusCount.hasOwnProperty(type)) {
            bonusCount[type] = 0;
          }
          bonusCount[type]++;
        }

        // If it is an alt arrangement build the appropriate name
        else if (arrangement['isAlternateArrangement']) {
          if (!altCount.hasOwnProperty(type)) {
            altCount[type] = 0;
          }
          altCount[type]++;
        }
      });

      // Keep track of bonus and alt indexes to handle bonus and alt arrangement types
      let bonusIndex = 1;
      let altIndex = 1;
      rocksnifferData['songDetails']['arrangements'].forEach((arrangement) => {
        const hash = arrangement['arrangementID'];

        let arrangementData = {};

        // Special logic to handle bonus and alt arrangement types
        const type = arrangement['type'];

        // If it is a bonus arrangement build the appropriate name
        if (arrangement['isBonusArrangement']) {
          arrangementData['name'] = 'Bonus ' + type;

          if (bonusCount[type] > 1) {
            arrangementData['name'] += ' ' + bonusIndex;
          }

          bonusIndex++;
        }

        // If it is an alt arrangement build the appropriate name
        else if (arrangement['isAlternateArrangement']) {
          arrangementData['name'] = 'Alternate ' + type;

          if (altCount[type] > 1) {
            arrangementData['name'] += ' ' + altIndex;
          }

          altIndex++
        }
        else {
          arrangementData['name'] = arrangement['type'];
        }

        arrangementData['hash'] = hash;

        const lasDataExists = rocksmithData['Stats']['Songs'].hasOwnProperty(hash);
        const saDataExists = rocksmithData['SongsSA'].hasOwnProperty(hash);
        if (lasDataExists) {
          arrangementData['accuracy'] = rocksmithData['Stats']['Songs'][hash]['AccuracyGlobal'];
          arrangementData['mastery'] = rocksmithData['Stats']['Songs'][hash]['MasteryPeak'];
          arrangementData['streak'] = rocksmithData['Stats']['Songs'][hash]['Streak'];
          arrangementData['las_last_played'] = rocksmithData['Stats']['Songs'][hash]['DateLAS'];
          arrangementData['las_play_count'] = rocksmithData['Stats']['Songs'][hash]['PlayedCount'];
        }
        if (saDataExists) {
          arrangementData['scores'] = {};
          arrangementData['badges'] = {};
          
          // Scores
          // Keep easy and medium commented out in case we want to add them later
          //arrangementData['scores']['easy'] = rocksmithData['SongsSA'][hash]['HighScores']['Easy'];
          //arrangementData['scores']['medium'] = rocksmithData['SongsSA'][hash]['HighScores']['Medium'];
          arrangementData['scores']['hard'] = rocksmithData['SongsSA'][hash]['HighScores']['Hard'];
          arrangementData['scores']['master'] = rocksmithData['SongsSA'][hash]['HighScores']['Master'];

          // Strikes
          // Keep easy and medium commented out in case we want to add them later
          //arrangementData['badges']['easy'] = rocksmithData['SongsSA'][hash]['Badges']['Easy'];
          //arrangementData['badges']['medium'] = rocksmithData['SongsSA'][hash]['Badges']['Medium'];
          arrangementData['badges']['hard'] = rocksmithData['SongsSA'][hash]['Badges']['Hard'];
          arrangementData['badges']['master'] = rocksmithData['SongsSA'][hash]['Badges']['Master'];

          arrangementData['sa_last_played'] = rocksmithData['Stats']['Songs'][hash]['DateSA'];
          arrangementData['sa_play_count'] = rocksmithData['SongsSA'][hash]['PlayCount'];
        }

        songData['arrangements'][hash] = arrangementData;
      });

      await writeSongData(songData);
    }

    async function checkForNewRocksmithProfileData() {
      const steamUserDataPath = sessionStorage.getItem('steam_user_data_path');
      const steamProfile = sessionStorage.getItem('steam_profile');
      const rocksmithProfile = sessionStorage.getItem('rocksmith_profile');

      return await api.checkForNewRocksmithProfileData(steamUserDataPath, steamProfile, rocksmithProfile);
    }

    async function getRocksmithProfileData() {
      const steamUserDataPath = sessionStorage.getItem('steam_user_data_path');
      const steamProfile = sessionStorage.getItem('steam_profile');
      const rocksmithProfile = sessionStorage.getItem('rocksmith_profile');

      return await api.getRocksmithProfileData(steamUserDataPath, steamProfile, rocksmithProfile);
    }

    async function getRocksnifferData() {
      const rocksnifferHost = sessionStorage.getItem('rocksniffer_host');
      const rocksnifferPort = sessionStorage.getItem('rocksniffer_port');

      //JSON query the addon service
      try {
        const response = await $.get("http://"+rocksnifferHost+":"+rocksnifferPort);
        showComponent('connected');

        let randomNumber = Math.floor(Math.random() * 69) + 1;
        if (randomNumber === 69) {
          console.log('*sniff sniff*');
        }

        return response;
      } catch (error) {
        showComponent('waiting');
        return null;
      }
    }

    async function showComponent(component) {
      const components = {
        loading: document.getElementById('loading'),
        error: document.getElementById('error'),
        waiting: document.getElementById('waiting'),
        connected: document.getElementById('connected')
      };

      const componentsKeys = Object.keys(components);
      componentsKeys.forEach((c) => {
        if (component === c) {
          components[c].style.display = 'block';
        }
        else {
          components[c].style.display = 'none';
        }
      });
    }

    async function connectToRocksmith() {
      let steamUserDataPath = sessionStorage.getItem('steam_user_data_path');
      let steamProfile = sessionStorage.getItem('steam_profile');
      let rocksmithProfile = sessionStorage.getItem('rocksmith_profile');

      if (steamUserDataPath === null || steamProfile === null || rocksmithProfile === null) {
        steamUserDataPath = await api.storeGet('steam_user_data_path');
        steamProfile = await api.storeGet('steam_profile');
        rocksmithProfile = await api.storeGet('rocksmith_profile');

        if (steamUserDataPath === null || steamProfile === null || rocksmithProfile === null) {
          document.getElementById('error').innerHTML = '<p>Could not find Rocksmith user data. Check that your config settings are correct.</p>';
          showComponent('error');
          return false;
        }

        sessionStorage.setItem('steam_user_data_path', steamUserDataPath);
        sessionStorage.setItem('steam_profile', steamProfile);
        sessionStorage.setItem('rocksmith_profile', rocksmithProfile);
      }

      return true;
    }

    async function connectToRocksniffer() {
      const rocksnifferHost = sessionStorage.getItem('rocksniffer_host');
      const rocksnifferPort = sessionStorage.getItem('rocksniffer_port');

      // If we don't have the host and port, get it
      if (rocksnifferHost === null || rocksnifferPort === null) {
        const rocksnifferPath = await api.storeGet('rocksniffer_path');
        if (rocksnifferPath === null) {
          document.getElementById('error').innerHTML = '<p>Could not find Rocksniffer. Check that your config settings are correct.</p>';
          showComponent('error');
          return false;
        }

        const addonConfigFile = await api.pathJoin(rocksnifferPath, 'config', 'addons.json');
        const addonConfig = JSON.parse(await api.readFile(addonConfigFile));

        // Make sure addons are enabled
        if (!addonConfig['enableAddons']) {
          console.log('Enabling Rocksniffer addons.');
          addonConfig['enableAddons'] = true;
          await api.writeFile(addonConfigFile, JSON.stringify(addonConfig, null, 2));
        }

        sessionStorage.setItem('rocksniffer_host', addonConfig['ipAddress']);
        sessionStorage.setItem('rocksniffer_port', addonConfig['port']);
      }

      return true;
    }

    async function main() {
      const rocksmithConnected = await connectToRocksmith();
      const rocksnifferConnected = await connectToRocksniffer();

      if (rocksmithConnected && rocksnifferConnected) {
        setInterval(refresh, pollRate);
        refresh();
      }
    }

    main();
  </script>
</body>
</html>